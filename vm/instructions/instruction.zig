const std = @import("std");

const Program = @import("../types/program.zig");
const Opcode = @import("../types/opcode.zig");

const ActivateThread = @import("activate_thread.zig");
const ControlThreads = @import("control_threads.zig");
const SetRegister = @import("set_register.zig");
const CopyRegister = @import("copy_register.zig");

pub const Error = 
    Program.Error || 
    ActivateThread.Error || 
    ControlThreads.Error || 
    SetRegister.Error || 
    CopyRegister.Error || 
    error {
    /// Bytecode contained an unrecognized opcode.
    UnsupportedOpcode,
};

/// A union type that wraps all possible bytecode instructions.
pub const Instruction = union(enum) {
    // TODO: see if we can codegen all this because it's going to get tiresome for 26-odd opcodes.
    ActivateThread: ActivateThread.Instance,
    ControlThreads: ControlThreads.Instance,
    SetRegister: SetRegister.Instance,
    CopyRegister: CopyRegister.Instance,

    /// Parse the next instruction from a bytecode program and wrap it in an Instruction union type.
    /// Returns the wrapped Instruction or an error if the bytecode could not be interpreted as an instruction.
    pub fn parse(program: *Program.Instance) Error!Instruction {
        const raw_opcode = try program.read(Opcode.Raw);
        const opcode = Opcode.parse(raw_opcode);

        return switch (opcode) {
            .ActivateThread => wrap("ActivateThread", ActivateThread.parse, raw_opcode, program),
            .ControlThreads => wrap("ControlThreads", ControlThreads.parse, raw_opcode, program),
            .SetRegister    => wrap("SetRegister", SetRegister.parse, raw_opcode, program),
            .CopyRegister   => wrap("CopyRegister", CopyRegister.parse, raw_opcode, program),
            else => error.UnsupportedOpcode,
        };
    }

    /// Parse an instruction of the specified type from the program,
    /// and wrap it in an Instruction union type initialized to the appropriate field.
    fn wrap(comptime field_name: []const u8, comptime parseFn: anytype, raw_opcode: Opcode.Raw, program: *Program.Instance) Error!Instruction {
        return @unionInit(Instruction, field_name, try parseFn(raw_opcode, program));
    }
};

// -- Test helpers --

/// Try to parse a literal sequence of bytecode into an Instruction union value.
fn debugParseInstruction(bytecode: []const u8) !Instruction {
    var program = Program.new(bytecode);
    return try Instruction.parse(&program);
}

/// Assert that an instruction previously generated by `parse` matches the expected union type.
/// (expectEqual won't coerce tagged unions to their underlying enum type, preventing easy comparison.)
fn expectInstructionType(expected: @TagType(Instruction), actual: @TagType(Instruction)) void {
    testing.expectEqual(expected, actual);
}

// -- Tests --

const testing = @import("../../utils/testing.zig");

test "parse returns ActivateThread instruction when given valid bytecode" {
    const instruction = try debugParseInstruction(&ActivateThread.BytecodeExamples.valid);
    expectInstructionType(.ActivateThread, instruction);
}

test "parse returns ControlThreads instruction when given valid bytecode" {
    const instruction = try debugParseInstruction(&ControlThreads.BytecodeExamples.valid);
    expectInstructionType(.ControlThreads, instruction);
}

test "parse returns SetRegister instruction when given valid bytecode" {
    const instruction = try debugParseInstruction(&SetRegister.BytecodeExamples.valid);
    expectInstructionType(.SetRegister, instruction);
}

test "parse returns CopyRegister instruction when given valid bytecode" {
    const instruction = try debugParseInstruction(&CopyRegister.BytecodeExamples.valid);
    expectInstructionType(.CopyRegister, instruction);
}

test "parse returns UnsupportedOpcode error when it encounters an unknown opcode" {
    const bytecode = [_]u8{ 0xFF }; // unknown opcode
    testing.expectError(error.UnsupportedOpcode, debugParseInstruction(&bytecode));
}