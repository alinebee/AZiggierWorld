const std = @import("std");

const Opcode = @import("opcode.zig").Opcode;

const activate_thread = @import("activate_thread.zig");
const control_threads = @import("control_threads.zig");

pub const Error = activate_thread.Error || control_threads.Error || error {
    /// Bytecode contained an unrecognized opcode.
    UnsupportedOpcode,
};

/// A union type encapsulating all possible bytecode instructions.
pub const Instruction = union(enum) {
    // TODO: see if we can codegen all this because it's going to get tiresome for 26-odd opcodes.
    ActivateThread: activate_thread.Instruction,
    ControlThreads: control_threads.Instruction,

    /// Parse an instruction from a sequence of Another World bytecode.
    /// Returns a valid instruction, or an error if the bytecode is truncated or could not be interpreted.
    pub fn parse(comptime ReaderType: type, reader: ReaderType) !Instruction {
        const rawOpcode = try reader.readByte();
        const opcode = @intToEnum(Opcode, rawOpcode);

        return switch (opcode) {
            .ActivateThread => Instruction { .ActivateThread = try activate_thread.Instruction.parse(ReaderType, rawOpcode, reader) },
            .ControlThreads => Instruction { .ControlThreads = try control_threads.Instruction.parse(ReaderType, rawOpcode, reader) },
            else => error.UnsupportedOpcode,
        };
    }
};

// -- Test helpers --

const BytecodeStream = @import("test_helpers.zig").BytecodeStream;

/// Try to parse a literal sequence of bytecode into an Instruction union value.
fn debugParseInstruction(bytecode: []const u8) !Instruction {
    const reader = BytecodeStream(bytecode).reader();
    return try Instruction.parse(@TypeOf(reader), reader);
}

/// Assert that an instruction previously generated by `parse` matches the expected union type.
fn expectInstructionType(instruction: Instruction, expected_enum: @TagType(Instruction)) void {
    // Coerce tagged union to its underlying enum type so that we can do a simple comparison.
    // Zig will automatically coerce unions to enums in some circumstances, but not here;
    // it otherwise demands we fully populate the comparison expression.
    testing.expectEqual(@as(@TagType(Instruction), instruction), expected_enum);
}

// -- Tests --

const testing = @import("std").testing;

test "parse returns ActivateThread instruction when given valid bytecode" {
    const instruction = try debugParseInstruction(&activate_thread.BytecodeExamples.valid);
    expectInstructionType(instruction, .ActivateThread);
}

test "parse returns ControlThreads instruction when given valid bytecode" {
    const instruction = try debugParseInstruction(&control_threads.BytecodeExamples.valid);
    expectInstructionType(instruction, .ControlThreads);
}

test "parse returns UnsupportedOpcode error when it encounters an unknown opcode" {
    const bytecode = [_]u8{ 0xFF }; // unknown opcode
    testing.expectError(error.UnsupportedOpcode, debugParseInstruction(&bytecode));
}