//! This file defines functions to parse and execute the instructions in Another World's bytecode programs.
//! Each instruction is modelled as its own separate Zig type; the functions in this file parse raw bytes
//! into the appropriate instruction type (and then execute it).
//!
//! Right now this file feels like a mess; there is a lot of copypasta that could probably
//! be cleaned up with some Zig compile-time code generation.

const anotherworld = @import("../anotherworld.zig");
const meta = @import("utils").meta;

const Program = @import("../../machine/program.zig").Program;
const Opcode = @import("opcode.zig").Opcode;
const Machine = @import("../../machine/machine.zig").Machine;
const ExecutionResult = @import("execution_result.zig").ExecutionResult;

pub const ExecutionError = error{
    /// Program execution reached its instruction limit without yielding or deactivating.
    /// This indicates either that the instruction limit was too low for the program's complexity
    /// or that the program contained a bug like an infinite loop.
    InstructionLimitExceeded,
};

/// Run the program from its current program counter, executing its instructions on the specified machine
/// until the program reaches a `Yield` or `Kill` instruction or exceeds the maximum iterations.
/// Returns `ExecutionResult` on success, reflecting whether the program yielded or killed the thread.
/// Returns an instruction-specific error if an instruction failed, or `error.InstructionLimitExceeded`
/// if the program exceeded `max_instructions` without reaching a `Yield` or `Kill` instruction.
pub fn executeProgram(program: *Program, machine: *Machine, max_instructions: usize) !ExecutionResult {
    var instructions_remaining = max_instructions;
    while (instructions_remaining > 0) : (instructions_remaining -= 1) {
        const possible_result = try executeNextInstruction(program, machine);
        return possible_result orelse continue;
    } else {
        // If we reach here without returning before now, it means the program got stuck in an infinite loop.
        return error.InstructionLimitExceeded;
    }
}

/// Parse and execute the next instruction from a bytecode program on the specified virtual machine.
/// Returns an enum indicating whether execution should continue or stop as a result of that instruction.
/// Returns an error if the bytecode could not be interpreted as an instruction.
pub fn executeNextInstruction(program: *Program, machine: *Machine) !?ExecutionResult {
    const raw_opcode = try program.read(Opcode.Raw);
    const opcode = try Opcode.parse(raw_opcode);

    // The reference implementation built its own jump table with function pointers indexed by opcode:
    // https://github.com/fabiensanglard/Another-World-Bytecode-Interpreter/blob/master/src/staticres.cpp#L24-L59
    // We could build our own jump table instead of this switch, but after looking at the assembly
    // generated by enum switches - even ones with gaps in the enum values - it appears a modern
    // compiler will do that work for us.
    // TODO: actually analyze this code to see what assembly gets generated here.
    return switch (opcode) {
        .ActivateThread => execute(Instruction.ActivateThread, raw_opcode, program, machine),
        .Call => execute(Instruction.Call, raw_opcode, program, machine),
        .ControlMusic => execute(Instruction.ControlMusic, raw_opcode, program, machine),
        .ControlResources => execute(Instruction.ControlResources, raw_opcode, program, machine),
        .ControlSound => execute(Instruction.ControlSound, raw_opcode, program, machine),
        .ControlThreads => execute(Instruction.ControlThreads, raw_opcode, program, machine),
        .CopyVideoBuffer => execute(Instruction.CopyVideoBuffer, raw_opcode, program, machine),
        .DrawBackgroundPolygon => execute(Instruction.DrawBackgroundPolygon, raw_opcode, program, machine),
        .DrawSpritePolygon => execute(Instruction.DrawSpritePolygon, raw_opcode, program, machine),
        .DrawString => execute(Instruction.DrawString, raw_opcode, program, machine),
        .FillVideoBuffer => execute(Instruction.FillVideoBuffer, raw_opcode, program, machine),
        .Jump => execute(Instruction.Jump, raw_opcode, program, machine),
        .JumpConditional => execute(Instruction.JumpConditional, raw_opcode, program, machine),
        .JumpIfNotZero => execute(Instruction.JumpIfNotZero, raw_opcode, program, machine),
        .Kill => execute(Instruction.Kill, raw_opcode, program, machine),
        .RegisterAdd => execute(Instruction.RegisterAdd, raw_opcode, program, machine),
        .RegisterAddConstant => execute(Instruction.RegisterAddConstant, raw_opcode, program, machine),
        .RegisterAnd => execute(Instruction.RegisterAnd, raw_opcode, program, machine),
        .RegisterCopy => execute(Instruction.RegisterCopy, raw_opcode, program, machine),
        .RegisterOr => execute(Instruction.RegisterOr, raw_opcode, program, machine),
        .RegisterSet => execute(Instruction.RegisterSet, raw_opcode, program, machine),
        .RegisterShiftLeft => execute(Instruction.RegisterShiftLeft, raw_opcode, program, machine),
        .RegisterShiftRight => execute(Instruction.RegisterShiftRight, raw_opcode, program, machine),
        .RegisterSubtract => execute(Instruction.RegisterSubtract, raw_opcode, program, machine),
        .RenderVideoBuffer => execute(Instruction.RenderVideoBuffer, raw_opcode, program, machine),
        .Return => execute(Instruction.Return, raw_opcode, program, machine),
        .SelectPalette => execute(Instruction.SelectPalette, raw_opcode, program, machine),
        .SelectVideoBuffer => execute(Instruction.SelectVideoBuffer, raw_opcode, program, machine),
        .Yield => execute(Instruction.Yield, raw_opcode, program, machine),
    };
}

fn execute(comptime SpecificInstruction: type, raw_opcode: Opcode.Raw, program: *Program, machine: *Machine) !?ExecutionResult {
    const instruction = try SpecificInstruction.parse(raw_opcode, program);

    // Zig 0.9.0 does not have a way to express "try this function if it returns an error set,
    // otherwise call it normally", hence we must check the return type at compile time and branch.
    const ReturnType = meta.ReturnType(instruction.execute);
    const returns_error = @typeInfo(ReturnType) == .ErrorUnion;
    const result = if (returns_error)
        try instruction.execute(machine)
    else
        instruction.execute(machine);

    // Check whether this instruction returned a specific execution result. Most instructions just return void.
    const returns_action = @TypeOf(result) == ExecutionResult;
    if (returns_action) {
        return result;
    } else {
        return null;
    }
}

/// A union that represents the set of all possible bytecode instructions, indexed by opcode.
/// This wrapped type is intended for introspection and reverse engineering of Another World
/// bytecode programs, and is not used directly in the emulator; during normal emulator flow,
/// individual instructions are executed immediately after being parsed to avoid switching twice.
pub const Instruction = union(Opcode) {
    ActivateThread: ActivateThread,
    Call: Call,
    ControlMusic: ControlMusic,
    ControlResources: ControlResources,
    ControlSound: ControlSound,
    ControlThreads: ControlThreads,
    CopyVideoBuffer: CopyVideoBuffer,
    DrawBackgroundPolygon: DrawBackgroundPolygon,
    DrawSpritePolygon: DrawSpritePolygon,
    DrawString: DrawString,
    FillVideoBuffer: FillVideoBuffer,
    Jump: Jump,
    JumpConditional: JumpConditional,
    JumpIfNotZero: JumpIfNotZero,
    Kill: Kill,
    RegisterAdd: RegisterAdd,
    RegisterAddConstant: RegisterAddConstant,
    RegisterAnd: RegisterAnd,
    RegisterCopy: RegisterCopy,
    RegisterOr: RegisterOr,
    RegisterSet: RegisterSet,
    RegisterShiftLeft: RegisterShiftLeft,
    RegisterShiftRight: RegisterShiftRight,
    RegisterSubtract: RegisterSubtract,
    RenderVideoBuffer: RenderVideoBuffer,
    Return: Return,
    SelectPalette: SelectPalette,
    SelectVideoBuffer: SelectVideoBuffer,
    Yield: Yield,

    pub const ActivateThread = @import("activate_thread.zig").ActivateThread;
    pub const Call = @import("call.zig").Call;
    pub const ControlMusic = @import("control_music.zig").ControlMusic;
    pub const ControlResources = @import("control_resources.zig").ControlResources;
    pub const ControlSound = @import("control_sound.zig").ControlSound;
    pub const ControlThreads = @import("control_threads.zig").ControlThreads;
    pub const CopyVideoBuffer = @import("copy_video_buffer.zig").CopyVideoBuffer;
    pub const DrawBackgroundPolygon = @import("draw_background_polygon.zig").DrawBackgroundPolygon;
    pub const DrawSpritePolygon = @import("draw_sprite_polygon.zig").DrawSpritePolygon;
    pub const DrawString = @import("draw_string.zig").DrawString;
    pub const FillVideoBuffer = @import("fill_video_buffer.zig").FillVideoBuffer;
    pub const Jump = @import("jump.zig").Jump;
    pub const JumpConditional = @import("jump_conditional.zig").JumpConditional;
    pub const JumpIfNotZero = @import("jump_if_not_zero.zig").JumpIfNotZero;
    pub const Kill = @import("kill.zig").Kill;
    pub const RegisterAdd = @import("register_add.zig").RegisterAdd;
    pub const RegisterAddConstant = @import("register_add_constant.zig").RegisterAddConstant;
    pub const RegisterAnd = @import("register_and.zig").RegisterAnd;
    pub const RegisterCopy = @import("register_copy.zig").RegisterCopy;
    pub const RegisterOr = @import("register_or.zig").RegisterOr;
    pub const RegisterSet = @import("register_set.zig").RegisterSet;
    pub const RegisterShiftLeft = @import("register_shift_left.zig").RegisterShiftLeft;
    pub const RegisterShiftRight = @import("register_shift_right.zig").RegisterShiftRight;
    pub const RegisterSubtract = @import("register_subtract.zig").RegisterSubtract;
    pub const RenderVideoBuffer = @import("render_video_buffer.zig").RenderVideoBuffer;
    pub const Return = @import("return.zig").Return;
    pub const SelectPalette = @import("select_palette.zig").SelectPalette;
    pub const SelectVideoBuffer = @import("select_video_buffer.zig").SelectVideoBuffer;
    pub const Yield = @import("yield.zig").Yield;

    /// Parse the next instruction from a bytecode program and wrap it in an Instruction union type.
    /// Returns the instruction or an error if the program could not be read or the bytecode
    /// could not be interpreted as an instruction.
    pub fn parse(program: *Program) !Instruction {
        const raw_opcode = try program.read(Opcode.Raw);
        const opcode = try Opcode.parse(raw_opcode);

        return switch (opcode) {
            .ActivateThread => parseSpecific(ActivateThread, raw_opcode, program),
            .Call => parseSpecific(Call, raw_opcode, program),
            .ControlMusic => parseSpecific(ControlMusic, raw_opcode, program),
            .ControlResources => parseSpecific(ControlResources, raw_opcode, program),
            .ControlSound => parseSpecific(ControlSound, raw_opcode, program),
            .ControlThreads => parseSpecific(ControlThreads, raw_opcode, program),
            .CopyVideoBuffer => parseSpecific(CopyVideoBuffer, raw_opcode, program),
            .DrawBackgroundPolygon => parseSpecific(DrawBackgroundPolygon, raw_opcode, program),
            .DrawSpritePolygon => parseSpecific(DrawSpritePolygon, raw_opcode, program),
            .DrawString => parseSpecific(DrawString, raw_opcode, program),
            .FillVideoBuffer => parseSpecific(FillVideoBuffer, raw_opcode, program),
            .Jump => parseSpecific(Jump, raw_opcode, program),
            .JumpConditional => parseSpecific(JumpConditional, raw_opcode, program),
            .JumpIfNotZero => parseSpecific(JumpIfNotZero, raw_opcode, program),
            .Kill => parseSpecific(Kill, raw_opcode, program),
            .RegisterAdd => parseSpecific(RegisterAdd, raw_opcode, program),
            .RegisterAddConstant => parseSpecific(RegisterAddConstant, raw_opcode, program),
            .RegisterAnd => parseSpecific(RegisterAnd, raw_opcode, program),
            .RegisterCopy => parseSpecific(RegisterCopy, raw_opcode, program),
            .RegisterOr => parseSpecific(RegisterOr, raw_opcode, program),
            .RegisterSet => parseSpecific(RegisterSet, raw_opcode, program),
            .RegisterShiftLeft => parseSpecific(RegisterShiftLeft, raw_opcode, program),
            .RegisterShiftRight => parseSpecific(RegisterShiftRight, raw_opcode, program),
            .RegisterSubtract => parseSpecific(RegisterSubtract, raw_opcode, program),
            .RenderVideoBuffer => parseSpecific(RenderVideoBuffer, raw_opcode, program),
            .Return => parseSpecific(Return, raw_opcode, program),
            .SelectPalette => parseSpecific(SelectPalette, raw_opcode, program),
            .SelectVideoBuffer => parseSpecific(SelectVideoBuffer, raw_opcode, program),
            .Yield => parseSpecific(Yield, raw_opcode, program),
        };
    }

    /// Parse an instruction of the specified type from the program,
    /// and wrap it in an Instruction union type initialized to the appropriate field.
    fn parseSpecific(comptime SpecificInstruction: type, raw_opcode: Opcode.Raw, program: *Program) !Instruction {
        const field_name = @tagName(SpecificInstruction.opcode);
        return @unionInit(Instruction, field_name, try SpecificInstruction.parse(raw_opcode, program));
    }
};

// -- Test helpers --

/// Try to parse a literal sequence of bytecode into an Instruction union value.
fn expectParse(bytecode: []const u8) !Instruction {
    var program = try Program.init(bytecode);
    return try Instruction.parse(&program);
}

// -- Tests --

const testing = @import("utils").testing;
const RegisterID = @import("../../values/register_id.zig").RegisterID;

// - Instruction.parse tests --

test "Instruction.parse returns expected instruction type when given valid bytecode" {
    try testing.expectEqualTags(.ActivateThread, try expectParse(&Instruction.ActivateThread.Fixtures.valid));
    try testing.expectEqualTags(.Call, try expectParse(&Instruction.Call.Fixtures.valid));
    try testing.expectEqualTags(.ControlMusic, try expectParse(&Instruction.ControlMusic.Fixtures.valid));
    try testing.expectEqualTags(.ControlResources, try expectParse(&Instruction.ControlResources.Fixtures.valid));
    try testing.expectEqualTags(.ControlSound, try expectParse(&Instruction.ControlSound.Fixtures.valid));
    try testing.expectEqualTags(.ControlThreads, try expectParse(&Instruction.ControlThreads.Fixtures.valid));
    try testing.expectEqualTags(.DrawBackgroundPolygon, try expectParse(&Instruction.DrawBackgroundPolygon.Fixtures.valid));
    try testing.expectEqualTags(.DrawSpritePolygon, try expectParse(&Instruction.DrawSpritePolygon.Fixtures.valid));
    try testing.expectEqualTags(.DrawString, try expectParse(&Instruction.DrawString.Fixtures.valid));
    try testing.expectEqualTags(.FillVideoBuffer, try expectParse(&Instruction.FillVideoBuffer.Fixtures.valid));
    try testing.expectEqualTags(.Jump, try expectParse(&Instruction.Jump.Fixtures.valid));
    try testing.expectEqualTags(.JumpConditional, try expectParse(&Instruction.JumpConditional.Fixtures.valid));
    try testing.expectEqualTags(.JumpIfNotZero, try expectParse(&Instruction.JumpIfNotZero.Fixtures.valid));
    try testing.expectEqualTags(.Kill, try expectParse(&Instruction.Kill.Fixtures.valid));
    try testing.expectEqualTags(.RegisterAdd, try expectParse(&Instruction.RegisterAdd.Fixtures.valid));
    try testing.expectEqualTags(.RegisterAddConstant, try expectParse(&Instruction.RegisterAddConstant.Fixtures.valid));
    try testing.expectEqualTags(.RegisterAnd, try expectParse(&Instruction.RegisterAnd.Fixtures.valid));
    try testing.expectEqualTags(.RegisterCopy, try expectParse(&Instruction.RegisterCopy.Fixtures.valid));
    try testing.expectEqualTags(.RegisterOr, try expectParse(&Instruction.RegisterOr.Fixtures.valid));
    try testing.expectEqualTags(.RegisterSet, try expectParse(&Instruction.RegisterSet.Fixtures.valid));
    try testing.expectEqualTags(.RegisterShiftLeft, try expectParse(&Instruction.RegisterShiftLeft.Fixtures.valid));
    try testing.expectEqualTags(.RegisterSubtract, try expectParse(&Instruction.RegisterSubtract.Fixtures.valid));
    try testing.expectEqualTags(.RenderVideoBuffer, try expectParse(&Instruction.RenderVideoBuffer.Fixtures.valid));
    try testing.expectEqualTags(.Return, try expectParse(&Instruction.Return.Fixtures.valid));
    try testing.expectEqualTags(.SelectPalette, try expectParse(&Instruction.SelectPalette.Fixtures.valid));
    try testing.expectEqualTags(.SelectVideoBuffer, try expectParse(&Instruction.SelectVideoBuffer.Fixtures.valid));
    try testing.expectEqualTags(.Yield, try expectParse(&Instruction.Yield.Fixtures.valid));
}

test "Instruction.parse returns error.InvalidOpcode error when it encounters an unknown opcode" {
    const bytecode = [_]u8{63}; // Not a valid opcode
    try testing.expectError(error.InvalidOpcode, expectParse(&bytecode));
}

// - executeNextInstruction tests -

test "executeNextInstruction executes arbitrary instruction on machine when given valid bytecode" {
    var machine = Machine.testInstance(.{ .bytecode = &Instruction.ControlResources.Fixtures.valid });
    defer machine.deinit();

    const result = try executeNextInstruction(&machine.program, &machine);

    try testing.expectEqual(null, result);
    try testing.expectEqual(.arena_cinematic, machine.scheduled_game_part);
}

test "executeNextInstruction returns ExecutionResult.deactivate if specified" {
    var machine = Machine.testInstance(.{ .bytecode = &Instruction.Kill.Fixtures.valid });
    defer machine.deinit();

    const result = try executeNextInstruction(&machine.program, &machine);

    try testing.expectEqual(.deactivate, result);
}

test "executeNextInstruction returns ExecutionResult.yield if specified" {
    var machine = Machine.testInstance(.{ .bytecode = &Instruction.Yield.Fixtures.valid });
    defer machine.deinit();

    const result = try executeNextInstruction(&machine.program, &machine);

    try testing.expectEqual(.yield, result);
}

// - executeProgram tests -

test "executeProgram ends execution on Yield instruction and returns ExecutionResult.yield" {
    const register_1 = RegisterID.cast(1);
    const register_2 = RegisterID.cast(2);
    const bytecode = [_]u8{
        Opcode.RegisterSet.encode(), register_1.encode(), 0x0B, 0xAD, // Offset 0: Set register 1 to 0x0BAD
        Opcode.Yield.encode(), // Offset 3: Yield current thread
        Opcode.RegisterSet.encode(), register_2.encode(), 0xF0, 0x0D, // Offset 5: Set register 2 to 0xF00D
    };

    var machine = Machine.testInstance(.{ .bytecode = &bytecode });
    defer machine.deinit();

    const result = try executeProgram(&machine.program, &machine, 10);
    try testing.expectEqual(.yield, result);

    // First register-set should have been executed
    try testing.expectEqual(0x0BAD, machine.registers.unsigned(register_1));
    // Second register-set should not have been executed
    try testing.expectEqual(0, machine.registers.unsigned(register_2));
}

test "executeProgram ends execution on Kill instruction and returns ExecutionResult.deactivate" {
    const register_1 = RegisterID.cast(1);
    const register_2 = RegisterID.cast(2);
    const bytecode = [_]u8{
        Opcode.RegisterSet.encode(), register_1.encode(), 0x0B, 0xAD, // Offset 0: Set register 1 to 0x0BAD
        Opcode.Kill.encode(), // Offset 3: Kill current thread
        Opcode.RegisterSet.encode(), register_2.encode(), 0xF0, 0x0D, // Offset 5: Set register 2 to 0xF00D
    };

    var machine = Machine.testInstance(.{ .bytecode = &bytecode });
    defer machine.deinit();

    const result = try executeProgram(&machine.program, &machine, 10);
    try testing.expectEqual(.deactivate, result);

    // First register-set should have been executed
    try testing.expectEqual(0x0BAD, machine.registers.unsigned(register_1));
    // Second register-set should not have been executed
    try testing.expectEqual(0, machine.registers.unsigned(register_2));
}

test "executeProgram returns error.InstructionLimitExceeded if program never yields or deactivates" {
    const register_1 = RegisterID.cast(1);
    const bytecode = [_]u8{
        Opcode.RegisterAddConstant.encode(), register_1.encode(), 0, 2, // Offset 0: add 2 to register 1
        Opcode.Jump.encode(), 0x00, 0x00, // Offset 4: jump to offset 0 (infinite loop)
    };

    const max_instructions = 10;

    var machine = Machine.testInstance(.{ .bytecode = &bytecode });
    defer machine.deinit();

    try testing.expectError(error.InstructionLimitExceeded, executeProgram(&machine.program, &machine, max_instructions));
    try testing.expectEqual(max_instructions, machine.registers.unsigned(register_1));
}
