const anotherworld = @import("../anotherworld.zig");
const vm = anotherworld.vm;

const meta = @import("utils").meta;

const Opcode = @import("opcode.zig").Opcode;
const Program = @import("program.zig").Program;
const Instruction = @import("instruction.zig").Instruction;
const ExecutionResult = @import("execution_result.zig").ExecutionResult;

pub const ExecutionError = error{
    /// Program execution reached its instruction limit without yielding or deactivating.
    /// This indicates either that the instruction limit was too low for the program's complexity
    /// or that the program contained a bug like an infinite loop.
    InstructionLimitExceeded,
};

/// Run the program from its current program counter, executing its instructions on the specified machine
/// until the program reaches a `Yield` or `Kill` instruction or exceeds the maximum iterations.
/// Returns `ExecutionResult` on success, reflecting whether the program yielded or killed the thread.
/// Returns an instruction-specific error if an instruction failed, or `error.InstructionLimitExceeded`
/// if the program exceeded `max_instructions` without reaching a `Yield` or `Kill` instruction.
pub fn executeProgram(program: *Program, machine: *vm.Machine, max_instructions: usize) !ExecutionResult {
    var instructions_remaining = max_instructions;
    while (instructions_remaining > 0) : (instructions_remaining -= 1) {
        const possible_result = try executeNextInstruction(program, machine);
        return possible_result orelse continue;
    } else {
        // If we reach here without returning before now, it means the program got stuck in an infinite loop.
        return error.InstructionLimitExceeded;
    }
}

/// Parse and execute the next instruction from a bytecode program on the specified virtual machine.
/// Returns an enum indicating whether execution should continue or stop as a result of that instruction.
/// Returns an error if the bytecode could not be interpreted as an instruction.
pub fn executeNextInstruction(program: *Program, machine: *vm.Machine) !?ExecutionResult {
    const raw_opcode = try program.read(Opcode.Raw);
    const opcode = try Opcode.parse(raw_opcode);

    // The reference implementation built its own jump table with function pointers indexed by opcode:
    // https://github.com/fabiensanglard/Another-World-Bytecode-Interpreter/blob/master/src/staticres.cpp#L24-L59
    // We could build our own jump table instead of this switch, but after looking at the assembly
    // generated by enum switches - even ones with gaps in the enum values - it appears a modern
    // compiler will do that work for us.
    // TODO: actually analyze this code to see what assembly gets generated here.
    return switch (opcode) {
        .ActivateThread => execute(Instruction.ActivateThread, raw_opcode, program, machine),
        .Call => execute(Instruction.Call, raw_opcode, program, machine),
        .ControlMusic => execute(Instruction.ControlMusic, raw_opcode, program, machine),
        .ControlResources => execute(Instruction.ControlResources, raw_opcode, program, machine),
        .ControlSound => execute(Instruction.ControlSound, raw_opcode, program, machine),
        .ControlThreads => execute(Instruction.ControlThreads, raw_opcode, program, machine),
        .CopyVideoBuffer => execute(Instruction.CopyVideoBuffer, raw_opcode, program, machine),
        .DrawBackgroundPolygon => execute(Instruction.DrawBackgroundPolygon, raw_opcode, program, machine),
        .DrawSpritePolygon => execute(Instruction.DrawSpritePolygon, raw_opcode, program, machine),
        .DrawString => execute(Instruction.DrawString, raw_opcode, program, machine),
        .FillVideoBuffer => execute(Instruction.FillVideoBuffer, raw_opcode, program, machine),
        .Jump => execute(Instruction.Jump, raw_opcode, program, machine),
        .JumpConditional => execute(Instruction.JumpConditional, raw_opcode, program, machine),
        .JumpIfNotZero => execute(Instruction.JumpIfNotZero, raw_opcode, program, machine),
        .Kill => execute(Instruction.Kill, raw_opcode, program, machine),
        .RegisterAdd => execute(Instruction.RegisterAdd, raw_opcode, program, machine),
        .RegisterAddConstant => execute(Instruction.RegisterAddConstant, raw_opcode, program, machine),
        .RegisterAnd => execute(Instruction.RegisterAnd, raw_opcode, program, machine),
        .RegisterCopy => execute(Instruction.RegisterCopy, raw_opcode, program, machine),
        .RegisterOr => execute(Instruction.RegisterOr, raw_opcode, program, machine),
        .RegisterSet => execute(Instruction.RegisterSet, raw_opcode, program, machine),
        .RegisterShiftLeft => execute(Instruction.RegisterShiftLeft, raw_opcode, program, machine),
        .RegisterShiftRight => execute(Instruction.RegisterShiftRight, raw_opcode, program, machine),
        .RegisterSubtract => execute(Instruction.RegisterSubtract, raw_opcode, program, machine),
        .RenderVideoBuffer => execute(Instruction.RenderVideoBuffer, raw_opcode, program, machine),
        .Return => execute(Instruction.Return, raw_opcode, program, machine),
        .SelectPalette => execute(Instruction.SelectPalette, raw_opcode, program, machine),
        .SelectVideoBuffer => execute(Instruction.SelectVideoBuffer, raw_opcode, program, machine),
        .Yield => execute(Instruction.Yield, raw_opcode, program, machine),
    };
}

fn execute(comptime SpecificInstruction: type, raw_opcode: Opcode.Raw, program: *Program, machine: *vm.Machine) !?ExecutionResult {
    const instruction = try SpecificInstruction.parse(raw_opcode, program);

    // Zig 0.9.0 does not have a way to express "try this function if it returns an error set,
    // otherwise call it normally", hence we must check the return type at compile time and branch.
    const ReturnType = meta.ReturnType(instruction.execute);
    const returns_error = @typeInfo(ReturnType) == .ErrorUnion;
    const result = if (returns_error)
        try instruction.execute(machine)
    else
        instruction.execute(machine);

    // Check whether this instruction returned a specific execution result. Most instructions just return void.
    const returns_action = @TypeOf(result) == ExecutionResult;
    if (returns_action) {
        return result;
    } else {
        return null;
    }
}

// -- Tests --

const testing = @import("utils").testing;

// - executeNextInstruction tests -

test "executeNextInstruction executes arbitrary instruction on machine when given valid bytecode" {
    var machine = vm.Machine.testInstance(.{ .program_data = &Instruction.ControlResources.Fixtures.valid });
    defer machine.deinit();

    const result = try executeNextInstruction(&machine.program, &machine);

    try testing.expectEqual(null, result);
    try testing.expectEqual(.arena_cinematic, machine.scheduled_game_part);
}

test "executeNextInstruction returns ExecutionResult.deactivate if specified" {
    var machine = vm.Machine.testInstance(.{ .program_data = &Instruction.Kill.Fixtures.valid });
    defer machine.deinit();

    const result = try executeNextInstruction(&machine.program, &machine);

    try testing.expectEqual(.deactivate, result);
}

test "executeNextInstruction returns ExecutionResult.yield if specified" {
    var machine = vm.Machine.testInstance(.{ .program_data = &Instruction.Yield.Fixtures.valid });
    defer machine.deinit();

    const result = try executeNextInstruction(&machine.program, &machine);

    try testing.expectEqual(.yield, result);
}

// - executeProgram tests -

test "executeProgram ends execution on Yield instruction and returns ExecutionResult.yield" {
    const register_1 = vm.RegisterID.cast(1);
    const register_2 = vm.RegisterID.cast(2);
    const program_data = [_]u8{
        Opcode.RegisterSet.encode(), register_1.encode(), 0x0B, 0xAD, // Offset 0: Set register 1 to 0x0BAD
        Opcode.Yield.encode(), // Offset 3: Yield current thread
        Opcode.RegisterSet.encode(), register_2.encode(), 0xF0, 0x0D, // Offset 5: Set register 2 to 0xF00D
    };

    var machine = vm.Machine.testInstance(.{ .program_data = &program_data });
    defer machine.deinit();

    const result = try executeProgram(&machine.program, &machine, 10);
    try testing.expectEqual(.yield, result);

    // First register-set should have been executed
    try testing.expectEqual(0x0BAD, machine.registers.unsigned(register_1));
    // Second register-set should not have been executed
    try testing.expectEqual(0, machine.registers.unsigned(register_2));
}

test "executeProgram ends execution on Kill instruction and returns ExecutionResult.deactivate" {
    const register_1 = vm.RegisterID.cast(1);
    const register_2 = vm.RegisterID.cast(2);
    const program_data = [_]u8{
        Opcode.RegisterSet.encode(), register_1.encode(), 0x0B, 0xAD, // Offset 0: Set register 1 to 0x0BAD
        Opcode.Kill.encode(), // Offset 3: Kill current thread
        Opcode.RegisterSet.encode(), register_2.encode(), 0xF0, 0x0D, // Offset 5: Set register 2 to 0xF00D
    };

    var machine = vm.Machine.testInstance(.{ .program_data = &program_data });
    defer machine.deinit();

    const result = try executeProgram(&machine.program, &machine, 10);
    try testing.expectEqual(.deactivate, result);

    // First register-set should have been executed
    try testing.expectEqual(0x0BAD, machine.registers.unsigned(register_1));
    // Second register-set should not have been executed
    try testing.expectEqual(0, machine.registers.unsigned(register_2));
}

test "executeProgram returns error.InstructionLimitExceeded if program never yields or deactivates" {
    const register_1 = vm.RegisterID.cast(1);
    const program_data = [_]u8{
        Opcode.RegisterAddConstant.encode(), register_1.encode(), 0, 2, // Offset 0: add 2 to register 1
        Opcode.Jump.encode(), 0x00, 0x00, // Offset 4: jump to offset 0 (infinite loop)
    };

    const max_instructions = 10;

    var machine = vm.Machine.testInstance(.{ .program_data = &program_data });
    defer machine.deinit();

    try testing.expectError(error.InstructionLimitExceeded, executeProgram(&machine.program, &machine, max_instructions));
    try testing.expectEqual(max_instructions, machine.registers.unsigned(register_1));
}
