//! This file defines functions to parse and execute the instructions in Another World's bytecode programs.
//! Each instruction is modelled as its own separate Zig type; the functions in this file parse raw bytes
//! into the appropriate instruction type (and then execute it).
//!
//! Right now this file feels like a mess; there is a lot of copypasta that could probably
//! be cleaned up with some Zig compile-time code generation.

const Program = @import("../machine/program.zig").Program;
const Opcode = @import("../values/opcode.zig");
const Machine = @import("../machine/machine.zig").Machine;
const ExecutionResult = @import("execution_result.zig");

const ActivateThread = @import("activate_thread.zig").ActivateThread;
const Call = @import("call.zig").Call;
const ControlMusic = @import("control_music.zig").ControlMusic;
const ControlResources = @import("control_resources.zig").ControlResources;
const ControlSound = @import("control_sound.zig").ControlSound;
const ControlThreads = @import("control_threads.zig");
const CopyVideoBuffer = @import("copy_video_buffer.zig");
const DrawBackgroundPolygon = @import("draw_background_polygon.zig");
const DrawSpritePolygon = @import("draw_sprite_polygon.zig");
const DrawString = @import("draw_string.zig");
const FillVideoBuffer = @import("fill_video_buffer.zig");
const Jump = @import("jump.zig");
const JumpConditional = @import("jump_conditional.zig");
const JumpIfNotZero = @import("jump_if_not_zero.zig");
const Kill = @import("kill.zig");
const RegisterAdd = @import("register_add.zig");
const RegisterAddConstant = @import("register_add_constant.zig");
const RegisterAnd = @import("register_and.zig");
const RegisterCopy = @import("register_copy.zig");
const RegisterOr = @import("register_or.zig");
const RegisterSet = @import("register_set.zig");
const RegisterShiftLeft = @import("register_shift_left.zig");
const RegisterShiftRight = @import("register_shift_right.zig");
const RegisterSubtract = @import("register_subtract.zig");
const RenderVideoBuffer = @import("render_video_buffer.zig");
const Return = @import("return.zig");
const SelectPalette = @import("select_palette.zig");
const SelectVideoBuffer = @import("select_video_buffer.zig");
const Yield = @import("yield.zig");

const introspection = @import("../utils/introspection.zig");

pub const ExecutionError = error{
    /// Program execution reached its instruction limit without yielding or deactivating.
    /// This indicates either that the instruction limit was too low for the program's complexity
    /// or that the program contained a bug like an infinite loop.
    InstructionLimitExceeded,
};

/// Run the program from its current program counter, executing its instructions on the specified machine
/// until the program reaches a `Yield` or `Kill` instruction or exceeds the maximum iterations.
/// Returns `ExecutionResult` on success, reflecting whether the program yielded or killed the thread.
/// Returns an instruction-specific error if an instruction failed, or `error.InstructionLimitExceeded`
/// if the program exceeded `max_instructions` without reaching a `Yield` or `Kill` instruction.
pub fn executeProgram(program: *Program, machine: *Machine, max_instructions: usize) !ExecutionResult.Enum {
    var instructions_remaining = max_instructions;
    while (instructions_remaining > 0) : (instructions_remaining -= 1) {
        const possible_result = try executeNextInstruction(program, machine);
        return possible_result orelse continue;
    } else {
        // If we reach here without returning before now, it means the program got stuck in an infinite loop.
        return error.InstructionLimitExceeded;
    }
}

/// Parse and execute the next instruction from a bytecode program on the specified virtual machine.
/// Returns an enum indicating whether execution should continue or stop as a result of that instruction.
/// Returns an error if the bytecode could not be interpreted as an instruction.
pub fn executeNextInstruction(program: *Program, machine: *Machine) !?ExecutionResult.Enum {
    const raw_opcode = try program.read(Opcode.Raw);
    const opcode = try Opcode.parse(raw_opcode);

    // The reference implementation built its own jump table with function pointers indexed by opcode:
    // https://github.com/fabiensanglard/Another-World-Bytecode-Interpreter/blob/master/src/staticres.cpp#L24-L59
    // We could build our own jump table instead of this switch, but after looking at the assembly
    // generated by enum switches - even ones with gaps in the enum values - it appears a modern
    // compiler will do that work for us.
    // TODO: actually analyze this code to see what assembly gets generated here.
    return switch (opcode) {
        .ActivateThread => execute(ActivateThread, raw_opcode, program, machine),
        .Call => execute(Call, raw_opcode, program, machine),
        .ControlMusic => execute(ControlMusic, raw_opcode, program, machine),
        .ControlResources => execute(ControlResources, raw_opcode, program, machine),
        .ControlSound => execute(ControlSound, raw_opcode, program, machine),
        .ControlThreads => execute(ControlThreads, raw_opcode, program, machine),
        .CopyVideoBuffer => execute(CopyVideoBuffer, raw_opcode, program, machine),
        .DrawBackgroundPolygon => execute(DrawBackgroundPolygon, raw_opcode, program, machine),
        .DrawSpritePolygon => execute(DrawSpritePolygon, raw_opcode, program, machine),
        .DrawString => execute(DrawString, raw_opcode, program, machine),
        .FillVideoBuffer => execute(FillVideoBuffer, raw_opcode, program, machine),
        .Jump => execute(Jump, raw_opcode, program, machine),
        .JumpConditional => execute(JumpConditional, raw_opcode, program, machine),
        .JumpIfNotZero => execute(JumpIfNotZero, raw_opcode, program, machine),
        .Kill => execute(Kill, raw_opcode, program, machine),
        .RegisterAdd => execute(RegisterAdd, raw_opcode, program, machine),
        .RegisterAddConstant => execute(RegisterAddConstant, raw_opcode, program, machine),
        .RegisterAnd => execute(RegisterAnd, raw_opcode, program, machine),
        .RegisterCopy => execute(RegisterCopy, raw_opcode, program, machine),
        .RegisterOr => execute(RegisterOr, raw_opcode, program, machine),
        .RegisterSet => execute(RegisterSet, raw_opcode, program, machine),
        .RegisterShiftLeft => execute(RegisterShiftLeft, raw_opcode, program, machine),
        .RegisterShiftRight => execute(RegisterShiftRight, raw_opcode, program, machine),
        .RegisterSubtract => execute(RegisterSubtract, raw_opcode, program, machine),
        .RenderVideoBuffer => execute(RenderVideoBuffer, raw_opcode, program, machine),
        .Return => execute(Return, raw_opcode, program, machine),
        .SelectPalette => execute(SelectPalette, raw_opcode, program, machine),
        .SelectVideoBuffer => execute(SelectVideoBuffer, raw_opcode, program, machine),
        .Yield => execute(Yield, raw_opcode, program, machine),
    };
}

fn execute(comptime Instruction: type, raw_opcode: Opcode.Raw, program: *Program, machine: *Machine) !?ExecutionResult.Enum {
    const instruction = try Instruction.parse(raw_opcode, program);

    // Zig 0.9.0 does not have a way to express "try this function if it returns an error set,
    // otherwise call it normally", hence we must check the return type at compile time and branch.
    const ReturnType = introspection.ReturnType(instruction.execute);
    const returns_error = @typeInfo(ReturnType) == .ErrorUnion;
    const result = if (returns_error)
        try instruction.execute(machine)
    else
        instruction.execute(machine);

    // Check whether this instruction returned a specific execution result. Most instructions just return void.
    const returns_action = @TypeOf(result) == ExecutionResult.Enum;
    if (returns_action) {
        return result;
    } else {
        return null;
    }
}

/// A union that represents the set of all possible bytecode instructions, indexed by opcode.
/// This wrapped type is intended for introspection and reverse engineering of Another World
/// bytecode programs, and is not used directly in the emulator; during normal emulator flow,
/// individual instructions are executed immediately after being parsed.
pub const Wrapped = union(Opcode.Enum) {
    ActivateThread: ActivateThread,
    Call: Call,
    ControlMusic: ControlMusic,
    ControlResources: ControlResources,
    ControlSound: ControlSound,
    ControlThreads: ControlThreads.Instance,
    CopyVideoBuffer: CopyVideoBuffer.Instance,
    DrawBackgroundPolygon: DrawBackgroundPolygon.Instance,
    DrawSpritePolygon: DrawSpritePolygon.Instance,
    DrawString: DrawString.Instance,
    FillVideoBuffer: FillVideoBuffer.Instance,
    Jump: Jump.Instance,
    JumpConditional: JumpConditional.Instance,
    JumpIfNotZero: JumpIfNotZero.Instance,
    Kill: Kill.Instance,
    RegisterAdd: RegisterAdd.Instance,
    RegisterAddConstant: RegisterAddConstant.Instance,
    RegisterAnd: RegisterAnd.Instance,
    RegisterCopy: RegisterCopy.Instance,
    RegisterOr: RegisterOr.Instance,
    RegisterSet: RegisterSet.Instance,
    RegisterShiftLeft: RegisterShiftLeft.Instance,
    RegisterShiftRight: RegisterShiftRight.Instance,
    RegisterSubtract: RegisterSubtract.Instance,
    RenderVideoBuffer: RenderVideoBuffer.Instance,
    Return: Return.Instance,
    SelectPalette: SelectPalette.Instance,
    SelectVideoBuffer: SelectVideoBuffer.Instance,
    Yield: Yield.Instance,
};

/// Parse the next instruction from a bytecode program and wrap it in a Wrapped union type.
/// Returns the wrapped instruction or an error if the program could not be read or the bytecode
/// could not be interpreted as an instruction.
pub fn parseNextInstruction(program: *Program) !Wrapped {
    const raw_opcode = try program.read(Opcode.Raw);
    const opcode = try Opcode.parse(raw_opcode);

    return switch (opcode) {
        .ActivateThread => parse(ActivateThread, raw_opcode, program),
        .Call => parse(Call, raw_opcode, program),
        .ControlMusic => parse(ControlMusic, raw_opcode, program),
        .ControlResources => parse(ControlResources, raw_opcode, program),
        .ControlSound => parse(ControlSound, raw_opcode, program),
        .ControlThreads => parse(ControlThreads, raw_opcode, program),
        .CopyVideoBuffer => parse(CopyVideoBuffer, raw_opcode, program),
        .DrawBackgroundPolygon => parse(DrawBackgroundPolygon, raw_opcode, program),
        .DrawSpritePolygon => parse(DrawSpritePolygon, raw_opcode, program),
        .DrawString => parse(DrawString, raw_opcode, program),
        .FillVideoBuffer => parse(FillVideoBuffer, raw_opcode, program),
        .Jump => parse(Jump, raw_opcode, program),
        .JumpConditional => parse(JumpConditional, raw_opcode, program),
        .JumpIfNotZero => parse(JumpIfNotZero, raw_opcode, program),
        .Kill => parse(Kill, raw_opcode, program),
        .RegisterAdd => parse(RegisterAdd, raw_opcode, program),
        .RegisterAddConstant => parse(RegisterAddConstant, raw_opcode, program),
        .RegisterAnd => parse(RegisterAnd, raw_opcode, program),
        .RegisterCopy => parse(RegisterCopy, raw_opcode, program),
        .RegisterOr => parse(RegisterOr, raw_opcode, program),
        .RegisterSet => parse(RegisterSet, raw_opcode, program),
        .RegisterShiftLeft => parse(RegisterShiftLeft, raw_opcode, program),
        .RegisterShiftRight => parse(RegisterShiftRight, raw_opcode, program),
        .RegisterSubtract => parse(RegisterSubtract, raw_opcode, program),
        .RenderVideoBuffer => parse(RenderVideoBuffer, raw_opcode, program),
        .Return => parse(Return, raw_opcode, program),
        .SelectPalette => parse(SelectPalette, raw_opcode, program),
        .SelectVideoBuffer => parse(SelectVideoBuffer, raw_opcode, program),
        .Yield => parse(Yield, raw_opcode, program),
    };
}

/// Parse an instruction of the specified type from the program,
/// and wrap it in a Wrapped union type initialized to the appropriate field.
fn parse(comptime Instruction: type, raw_opcode: Opcode.Raw, program: *Program) !Wrapped {
    const opcode_name = @tagName(Instruction.opcode);
    return @unionInit(Wrapped, opcode_name, try Instruction.parse(raw_opcode, program));
}

// -- Test helpers --

/// Try to parse a literal sequence of bytecode into an Instruction union value.
fn expectParse(bytecode: []const u8) !Wrapped {
    var program = Program.init(bytecode);
    return try parseNextInstruction(&program);
}

// -- Tests --

const testing = @import("../utils/testing.zig");
const RegisterID = @import("../values/register_id.zig");

// - parseNextInstruction tests --

test "parseNextInstruction returns expected instruction type when given valid bytecode" {
    try testing.expectEqualTags(.ActivateThread, try expectParse(&ActivateThread.Fixtures.valid));
    try testing.expectEqualTags(.Call, try expectParse(&Call.Fixtures.valid));
    try testing.expectEqualTags(.ControlMusic, try expectParse(&ControlMusic.Fixtures.valid));
    try testing.expectEqualTags(.ControlResources, try expectParse(&ControlResources.Fixtures.valid));
    try testing.expectEqualTags(.ControlSound, try expectParse(&ControlSound.Fixtures.valid));
    try testing.expectEqualTags(.ControlThreads, try expectParse(&ControlThreads.Fixtures.valid));
    try testing.expectEqualTags(.DrawBackgroundPolygon, try expectParse(&DrawBackgroundPolygon.Fixtures.valid));
    try testing.expectEqualTags(.DrawSpritePolygon, try expectParse(&DrawSpritePolygon.Fixtures.valid));
    try testing.expectEqualTags(.DrawString, try expectParse(&DrawString.Fixtures.valid));
    try testing.expectEqualTags(.FillVideoBuffer, try expectParse(&FillVideoBuffer.Fixtures.valid));
    try testing.expectEqualTags(.Jump, try expectParse(&Jump.Fixtures.valid));
    try testing.expectEqualTags(.JumpConditional, try expectParse(&JumpConditional.Fixtures.valid));
    try testing.expectEqualTags(.JumpIfNotZero, try expectParse(&JumpIfNotZero.Fixtures.valid));
    try testing.expectEqualTags(.Kill, try expectParse(&Kill.Fixtures.valid));
    try testing.expectEqualTags(.RegisterAdd, try expectParse(&RegisterAdd.Fixtures.valid));
    try testing.expectEqualTags(.RegisterAddConstant, try expectParse(&RegisterAddConstant.Fixtures.valid));
    try testing.expectEqualTags(.RegisterAnd, try expectParse(&RegisterAnd.Fixtures.valid));
    try testing.expectEqualTags(.RegisterCopy, try expectParse(&RegisterCopy.Fixtures.valid));
    try testing.expectEqualTags(.RegisterOr, try expectParse(&RegisterOr.Fixtures.valid));
    try testing.expectEqualTags(.RegisterSet, try expectParse(&RegisterSet.Fixtures.valid));
    try testing.expectEqualTags(.RegisterShiftLeft, try expectParse(&RegisterShiftLeft.Fixtures.valid));
    try testing.expectEqualTags(.RegisterSubtract, try expectParse(&RegisterSubtract.Fixtures.valid));
    try testing.expectEqualTags(.RenderVideoBuffer, try expectParse(&RenderVideoBuffer.Fixtures.valid));
    try testing.expectEqualTags(.Return, try expectParse(&Return.Fixtures.valid));
    try testing.expectEqualTags(.SelectPalette, try expectParse(&SelectPalette.Fixtures.valid));
    try testing.expectEqualTags(.SelectVideoBuffer, try expectParse(&SelectVideoBuffer.Fixtures.valid));
    try testing.expectEqualTags(.Yield, try expectParse(&Yield.Fixtures.valid));
}

test "parseNextInstruction returns error.InvalidOpcode error when it encounters an unknown opcode" {
    const bytecode = [_]u8{63}; // Not a valid opcode
    try testing.expectError(error.InvalidOpcode, expectParse(&bytecode));
}

// - executeNextInstruction tests -

test "executeNextInstruction executes arbitrary instruction on machine when given valid bytecode" {
    var machine = Machine.testInstance(.{ .bytecode = &ControlResources.Fixtures.valid });
    defer machine.deinit();

    const result = try executeNextInstruction(&machine.program, &machine);

    try testing.expectEqual(null, result);
    try testing.expectEqual(.arena_cinematic, machine.scheduled_game_part);
}

test "executeNextInstruction returns ExecutionResult.deactivate if specified" {
    var machine = Machine.testInstance(.{ .bytecode = &Kill.Fixtures.valid });
    defer machine.deinit();

    const result = try executeNextInstruction(&machine.program, &machine);

    try testing.expectEqual(.deactivate, result);
}

test "executeNextInstruction returns ExecutionResult.yield if specified" {
    var machine = Machine.testInstance(.{ .bytecode = &Yield.Fixtures.valid });
    defer machine.deinit();

    const result = try executeNextInstruction(&machine.program, &machine);

    try testing.expectEqual(.yield, result);
}

// - executeProgram tests -

test "executeProgram ends execution on Yield instruction and returns ExecutionResult.yield" {
    const register_1 = RegisterID.parse(1);
    const register_2 = RegisterID.parse(2);
    const bytecode = [_]u8{
        @enumToInt(Opcode.Enum.RegisterSet), @enumToInt(register_1), 0x0B, 0xAD, // Offset 0: Set register 1 to 0x0BAD
        @enumToInt(Opcode.Enum.Yield), // Offset 3: Yield current thread
        @enumToInt(Opcode.Enum.RegisterSet), @enumToInt(register_2), 0xF0, 0x0D, // Offset 5: Set register 2 to 0xF00D
    };

    var machine = Machine.testInstance(.{ .bytecode = &bytecode });
    defer machine.deinit();

    const result = try executeProgram(&machine.program, &machine, 10);
    try testing.expectEqual(.yield, result);

    // First register-set should have been executed
    try testing.expectEqual(0x0BAD, machine.registers.unsigned(register_1));
    // Second register-set should not have been executed
    try testing.expectEqual(0, machine.registers.unsigned(register_2));
}

test "executeProgram ends execution on Kill instruction and returns ExecutionResult.deactivate" {
    const register_1 = RegisterID.parse(1);
    const register_2 = RegisterID.parse(2);
    const bytecode = [_]u8{
        @enumToInt(Opcode.Enum.RegisterSet), @enumToInt(register_1), 0x0B, 0xAD, // Offset 0: Set register 1 to 0x0BAD
        @enumToInt(Opcode.Enum.Kill), // Offset 3: Kill current thread
        @enumToInt(Opcode.Enum.RegisterSet), @enumToInt(register_2), 0xF0, 0x0D, // Offset 5: Set register 2 to 0xF00D
    };

    var machine = Machine.testInstance(.{ .bytecode = &bytecode });
    defer machine.deinit();

    const result = try executeProgram(&machine.program, &machine, 10);
    try testing.expectEqual(.deactivate, result);

    // First register-set should have been executed
    try testing.expectEqual(0x0BAD, machine.registers.unsigned(register_1));
    // Second register-set should not have been executed
    try testing.expectEqual(0, machine.registers.unsigned(register_2));
}

test "executeProgram returns error.InstructionLimitExceeded if program never yields or deactivates" {
    const register_1 = RegisterID.parse(1);
    const bytecode = [_]u8{
        @enumToInt(Opcode.Enum.RegisterAddConstant), @enumToInt(register_1), 0, 2, // Offset 0: add 2 to register 1
        @enumToInt(Opcode.Enum.Jump), 0x00, 0x00, // Offset 4: jump to offset 0 (infinite loop)
    };

    const max_instructions = 10;

    var machine = Machine.testInstance(.{ .bytecode = &bytecode });
    defer machine.deinit();

    try testing.expectError(error.InstructionLimitExceeded, executeProgram(&machine.program, &machine, max_instructions));
    try testing.expectEqual(max_instructions, machine.registers.unsigned(register_1));
}
